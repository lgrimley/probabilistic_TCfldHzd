geom_path(data = rp_contour, aes(x = x, y = y, color = pdf), size = 1.5) +
# Points
geom_point(aes(x = closest_most_likely_point[[xvar]], y = closest_most_likely_point[[yvar]]),
color='black', fill = "firebrick1", size = 4, shape = 21, stroke=1) +   # Closest raw point
geom_point(aes(x = closest_x_marginal_point[[xvar]], y = closest_x_marginal_point[[yvar]]),
color='black', fill = "steelblue2", size = 4, shape = 22, stroke=1) + # Closest x marginal
geom_point(aes(x = closest_y_marginal_point[[xvar]], y = closest_y_marginal_point[[yvar]]),
color='black', fill = "seagreen", size = 4, shape = 22, stroke=1) +# Closest y marginal
annotate("text", x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.95,
label = paste0("Most likely Joint TC_ID: ", closest_most_likely_point$TC_ID),
color = "firebrick1", hjust = 1, size = 4,fontface='bold') +
annotate("text", x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.90,
label = paste0("Closest X marginal TC_ID: ", closest_x_marginal_point$TC_ID),
color = "steelblue2", hjust = 1, size = 4,fontface='bold') +
annotate("text",
x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.85,
label = paste0("Closest Y marginal TC_ID: ", closest_y_marginal_point$TC_ID),
color = "seagreen", hjust = 1, size = 4, fontface='bold') +
scale_color_viridis_c(option = "inferno", name = "Probability\nDensity") +
theme_minimal() +
ggtitle(paste("Basin:", basin, "| Return Period:", target_rp))
break
output_filepath <- file.path(outputdir, paste(basin, target_rp, xvar, yvar, ".png", sep='_'))
ggsave(output_filepath, width = 6,height = 5, dpi = 300, bg='white')
}
}
}
# Compute RP contour and PDF
rp_contour <- joint_return_period_contour(result, target_rp = target_rp, lambda = 3.38)
rp_contour$pdf <- (rp_contour$pdf - min(rp_contour$pdf)) / (max(rp_contour$pdf) - min(rp_contour$pdf))
# Find the most likely point along the isoline
max_pdf_index <- which.max(rp_contour$pdf)
most_likely_point <- rp_contour[max_pdf_index, c("x", "y")]
# Closest raw data point to most likely point
distances <- rdist(as.matrix(df[, c(xvar, yvar)]), as.matrix(most_likely_point))
closest_most_likely_index <- which.min(distances)
closest_most_likely_point <- df[closest_most_likely_index, c(xvar, yvar)]
closest_most_likely_point$TC_ID <- closest_most_likely_index
# --- Compute marginal quantiles directly from the fitted distributions ---
p_selected <- 1 - 1/target_rp
x_params <- result$marginals$x$fit$estimate
y_params <- result$marginals$y$fit$estimate
# Compute marginal 100-yr quantiles
x_marginal_sel <- do.call(result$marginals$x$quantile, c(list(p = p_selected), as.list(x_params)))
y_marginal_sel <- do.call(result$marginals$y$quantile, c(list(p = p_selected), as.list(y_params)))
# -------------------------------
# Select the events **near isoline** first
# -------------------------------
tolerance <- 1 # adjust based on data scale
dist_to_isoline <- rdist(as.matrix(df[, c(xvar, yvar)]), as.matrix(rp_contour[, c("x", "y")]))
min_dist_to_isoline <- apply(dist_to_isoline, 1, min)
df_on_isoline <- df[min_dist_to_isoline < tolerance, , drop = FALSE]
# Save original row indices as TC_ID
df_on_isoline$TC_ID <- as.integer(rownames(df_on_isoline))
# Closest points to marginals on isoline
closest_x_marginal_index <- which.min(abs(df_on_isoline[[xvar]] - x_marginal_sel))
closest_y_marginal_index <- which.min(abs(df_on_isoline[[yvar]] - y_marginal_sel))
closest_x_marginal_point <- df_on_isoline[closest_x_marginal_index, c(xvar, yvar, "TC_ID")]
closest_y_marginal_point <- df_on_isoline[closest_y_marginal_index, c(xvar, yvar, "TC_ID")]
# Append to results table
selected_points <- rbind(selected_points,
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_most_likely_point$TC_ID,
point_type = "Most likely joint"),
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_x_marginal_point$TC_ID,
point_type = "Closest X marginal"),
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_y_marginal_point$TC_ID,
point_type = "Closest Y marginal"))
# Global settings
setwd('C:\\Users\\lelise\\Documents\\GitHub\\flood_model_carolinas\\syntheticTCs_cmpdfld\\analysis\\05_copula')
source("fit_marginals_and_copula.R")
source("joint_return_period_contour.R")
library(ggplot2)
library(fields) # rdist for pairwise Euclidean distances
library(akima)
library(patchwork)
datadir = 'Z:\\Data-Expansion\\users\\lelise\\projects\\Carolinas_SFINCS\\Chapter3_SyntheticTCs\\05_ANALYSIS\\01_return_period_tables'
outputdir = 'Z:\\Data-Expansion\\users\\lelise\\projects\\Carolinas_SFINCS\\Chapter3_SyntheticTCs\\05_ANALYSIS\\06_copula\\design_events'
# Define variable pairs
variable_pairs <- list(
list(xvar = 'stormtide', yvar = 'AvgmaxRR', zvar = 'Total_Area_sqkm_RP', climate='ncep'),
list(xvar = 'meanMaxWS', yvar = 'MeanTotPrecipMM', zvar = 'Total_Area_sqkm_RP', climate='ncep')
)
basins <- c('Neuse') #, 'Pamlico')#, c('OnslowBay','Pamlico') #c('LowerPeeDee','CapeFear')
rps <- c(5, 7, 10, 12, 15, 20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100, 150, 200, 250, 300, 400, 500)
# Initialize an empty data frame to store all selected points
selected_points <- data.frame(
basin = character(),
return_period = numeric(),
TC_ID = integer(),
point_type = character(),
stringsAsFactors = FALSE
)
for (basin in basins) {
for (pair in variable_pairs) {
xvar <- pair$xvar
yvar <- pair$yvar
zvar <- pair$zvar
climate <- pair$climate
# Load and clean data
filepath <- file.path(datadir, paste0(basin, "_data_rp_", climate, ".csv"))
if (!file.exists(filepath)) next
df <- read.csv(filepath)[, c(xvar, yvar, zvar,
'Runoff_Area_sqkm_RP',
'Coastal_Area_sqkm_RP',
'Compound_Area_sqkm_RP')]
df <- na.omit(df)
# Fit marginals and copula
x <- df[[xvar]]
y <- df[[yvar]]
result <- fit_marginals_and_copula(x, y)
for (target_rp in rps){
break
# Compute RP contour and PDF
rp_contour <- joint_return_period_contour(result, target_rp = target_rp, lambda = 3.38)
rp_contour$pdf <- (rp_contour$pdf - min(rp_contour$pdf)) / (max(rp_contour$pdf) - min(rp_contour$pdf))
# Find the most likely point along the isoline
max_pdf_index <- which.max(rp_contour$pdf)
most_likely_point <- rp_contour[max_pdf_index, c("x", "y")]
# Closest raw data point to most likely point
distances <- rdist(as.matrix(df[, c(xvar, yvar)]), as.matrix(most_likely_point))
closest_most_likely_index <- which.min(distances)
closest_most_likely_point <- df[closest_most_likely_index, c(xvar, yvar)]
closest_most_likely_point$TC_ID <- closest_most_likely_index
# --- Compute marginal quantiles directly from the fitted distributions ---
p_selected <- 1 - 1/target_rp
x_params <- result$marginals$x$fit$estimate
y_params <- result$marginals$y$fit$estimate
# Compute marginal 100-yr quantiles
x_marginal_sel <- do.call(result$marginals$x$quantile, c(list(p = p_selected), as.list(x_params)))
y_marginal_sel <- do.call(result$marginals$y$quantile, c(list(p = p_selected), as.list(y_params)))
# -------------------------------
# Select the events **near isoline** first
# -------------------------------
tolerance <- 1 # adjust based on data scale
dist_to_isoline <- rdist(as.matrix(df[, c(xvar, yvar)]), as.matrix(rp_contour[, c("x", "y")]))
min_dist_to_isoline <- apply(dist_to_isoline, 1, min)
df_on_isoline <- df[min_dist_to_isoline < tolerance, , drop = FALSE]
# Save original row indices as TC_ID
df_on_isoline$TC_ID <- as.integer(rownames(df_on_isoline))
# Closest points to marginals on isoline
closest_x_marginal_index <- which.min(abs(df_on_isoline[[xvar]] - x_marginal_sel))
closest_y_marginal_index <- which.min(abs(df_on_isoline[[yvar]] - y_marginal_sel))
closest_x_marginal_point <- df_on_isoline[closest_x_marginal_index, c(xvar, yvar, "TC_ID")]
closest_y_marginal_point <- df_on_isoline[closest_y_marginal_index, c(xvar, yvar, "TC_ID")]
# Append to results table
selected_points <- rbind(selected_points,
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_most_likely_point$TC_ID,
point_type = "Most likely joint"),
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_x_marginal_point$TC_ID,
point_type = "Closest X marginal"),
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_y_marginal_point$TC_ID,
point_type = "Closest Y marginal"))
# Plot
ggplot() +
geom_point(data = df, aes_string(x = xvar, y = yvar), alpha = 0.5) +
geom_path(data = rp_contour, aes(x = x, y = y, color = pdf), size = 1.5) +
# Points
geom_point(aes(x = closest_most_likely_point[[xvar]], y = closest_most_likely_point[[yvar]]),
color='black', fill = "firebrick1", size = 4, shape = 21, stroke=1) +   # Closest raw point
geom_point(aes(x = closest_x_marginal_point[[xvar]], y = closest_x_marginal_point[[yvar]]),
color='black', fill = "steelblue2", size = 4, shape = 22, stroke=1) + # Closest x marginal
geom_point(aes(x = closest_y_marginal_point[[xvar]], y = closest_y_marginal_point[[yvar]]),
color='black', fill = "seagreen", size = 4, shape = 22, stroke=1) +# Closest y marginal
annotate("text", x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.95,
label = paste0("Most likely Joint TC_ID: ", closest_most_likely_point$TC_ID),
color = "firebrick1", hjust = 1, size = 4,fontface='bold') +
annotate("text", x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.90,
label = paste0("Closest X marginal TC_ID: ", closest_x_marginal_point$TC_ID),
color = "steelblue2", hjust = 1, size = 4,fontface='bold') +
annotate("text",
x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.85,
label = paste0("Closest Y marginal TC_ID: ", closest_y_marginal_point$TC_ID),
color = "seagreen", hjust = 1, size = 4, fontface='bold') +
scale_color_viridis_c(option = "inferno", name = "Probability\nDensity") +
theme_minimal() +
ggtitle(paste("Basin:", basin, "| Return Period:", target_rp))
break
output_filepath <- file.path(outputdir, paste(basin, target_rp, xvar, yvar, ".png", sep='_'))
ggsave(output_filepath, width = 6,height = 5, dpi = 300, bg='white')
}
}
}
pairs
# Compute RP contour and PDF
rp_contour <- joint_return_period_contour(result, target_rp = target_rp, lambda = 3.38)
rp_contour$pdf <- (rp_contour$pdf - min(rp_contour$pdf)) / (max(rp_contour$pdf) - min(rp_contour$pdf))
# Find the most likely point along the isoline
max_pdf_index <- which.max(rp_contour$pdf)
most_likely_point <- rp_contour[max_pdf_index, c("x", "y")]
# Global settings
setwd('C:\\Users\\lelise\\Documents\\GitHub\\flood_model_carolinas\\syntheticTCs_cmpdfld\\analysis\\05_copula')
source("fit_marginals_and_copula.R")
source("joint_return_period_contour.R")
library(ggplot2)
library(fields) # rdist for pairwise Euclidean distances
library(akima)
library(patchwork)
datadir = 'Z:\\Data-Expansion\\users\\lelise\\projects\\Carolinas_SFINCS\\Chapter3_SyntheticTCs\\05_ANALYSIS\\01_return_period_tables'
outputdir = 'Z:\\Data-Expansion\\users\\lelise\\projects\\Carolinas_SFINCS\\Chapter3_SyntheticTCs\\05_ANALYSIS\\06_copula\\design_events'
# Define variable pairs
variable_pairs <- list(
list(xvar = 'stormtide', yvar = 'AvgmaxRR', zvar = 'Total_Area_sqkm_RP', climate='ncep'),
list(xvar = 'meanMaxWS', yvar = 'MeanTotPrecipMM', zvar = 'Total_Area_sqkm_RP', climate='ncep')
)
basins <- c('Neuse') #, 'Pamlico')#, c('OnslowBay','Pamlico') #c('LowerPeeDee','CapeFear')
rps <- c(100, 150, 200, 250, 300, 400, 500)
# Initialize an empty data frame to store all selected points
selected_points <- data.frame(
basin = character(),
return_period = numeric(),
TC_ID = integer(),
point_type = character(),
stringsAsFactors = FALSE
)
for (basin in basins) {
for (pair in variable_pairs) {
xvar <- pair$xvar
yvar <- pair$yvar
zvar <- pair$zvar
climate <- pair$climate
# Load and clean data
filepath <- file.path(datadir, paste0(basin, "_data_rp_", climate, ".csv"))
if (!file.exists(filepath)) next
df <- read.csv(filepath)[, c(xvar, yvar, zvar,
'Runoff_Area_sqkm_RP',
'Coastal_Area_sqkm_RP',
'Compound_Area_sqkm_RP')]
df <- na.omit(df)
# Fit marginals and copula
x <- df[[xvar]]
y <- df[[yvar]]
result <- fit_marginals_and_copula(x, y)
for (target_rp in rps){
# Compute RP contour and PDF
rp_contour <- joint_return_period_contour(result, target_rp = target_rp, lambda = 3.38)
rp_contour$pdf <- (rp_contour$pdf - min(rp_contour$pdf)) / (max(rp_contour$pdf) - min(rp_contour$pdf))
# Find the most likely point along the isoline
max_pdf_index <- which.max(rp_contour$pdf)
most_likely_point <- rp_contour[max_pdf_index, c("x", "y")]
# Closest raw data point to most likely point
distances <- rdist(as.matrix(df[, c(xvar, yvar)]), as.matrix(most_likely_point))
closest_most_likely_index <- which.min(distances)
closest_most_likely_point <- df[closest_most_likely_index, c(xvar, yvar)]
closest_most_likely_point$TC_ID <- closest_most_likely_index
# --- Compute marginal quantiles directly from the fitted distributions ---
p_selected <- 1 - 1/target_rp
x_params <- result$marginals$x$fit$estimate
y_params <- result$marginals$y$fit$estimate
# Compute marginal 100-yr quantiles
x_marginal_sel <- do.call(result$marginals$x$quantile, c(list(p = p_selected), as.list(x_params)))
y_marginal_sel <- do.call(result$marginals$y$quantile, c(list(p = p_selected), as.list(y_params)))
# -------------------------------
# Select the events **near isoline** first
# -------------------------------
tolerance <- 1 # adjust based on data scale
dist_to_isoline <- rdist(as.matrix(df[, c(xvar, yvar)]), as.matrix(rp_contour[, c("x", "y")]))
min_dist_to_isoline <- apply(dist_to_isoline, 1, min)
df_on_isoline <- df[min_dist_to_isoline < tolerance, , drop = FALSE]
# Save original row indices as TC_ID
df_on_isoline$TC_ID <- as.integer(rownames(df_on_isoline))
# Closest points to marginals on isoline
closest_x_marginal_index <- which.min(abs(df_on_isoline[[xvar]] - x_marginal_sel))
closest_y_marginal_index <- which.min(abs(df_on_isoline[[yvar]] - y_marginal_sel))
closest_x_marginal_point <- df_on_isoline[closest_x_marginal_index, c(xvar, yvar, "TC_ID")]
closest_y_marginal_point <- df_on_isoline[closest_y_marginal_index, c(xvar, yvar, "TC_ID")]
# Append to results table
selected_points <- rbind(selected_points,
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_most_likely_point$TC_ID,
point_type = "Most likely joint"),
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_x_marginal_point$TC_ID,
point_type = "Closest X marginal"),
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_y_marginal_point$TC_ID,
point_type = "Closest Y marginal"))
# Plot
ggplot() +
geom_point(data = df, aes_string(x = xvar, y = yvar), alpha = 0.5) +
geom_path(data = rp_contour, aes(x = x, y = y, color = pdf), size = 1.5) +
# Points
geom_point(aes(x = closest_most_likely_point[[xvar]], y = closest_most_likely_point[[yvar]]),
color='black', fill = "firebrick1", size = 4, shape = 21, stroke=1) +   # Closest raw point
geom_point(aes(x = closest_x_marginal_point[[xvar]], y = closest_x_marginal_point[[yvar]]),
color='black', fill = "steelblue2", size = 4, shape = 22, stroke=1) + # Closest x marginal
geom_point(aes(x = closest_y_marginal_point[[xvar]], y = closest_y_marginal_point[[yvar]]),
color='black', fill = "seagreen", size = 4, shape = 22, stroke=1) +# Closest y marginal
annotate("text", x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.95,
label = paste0("Most likely Joint TC_ID: ", closest_most_likely_point$TC_ID),
color = "firebrick1", hjust = 1, size = 4,fontface='bold') +
annotate("text", x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.90,
label = paste0("Closest X marginal TC_ID: ", closest_x_marginal_point$TC_ID),
color = "steelblue2", hjust = 1, size = 4,fontface='bold') +
annotate("text",
x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.85,
label = paste0("Closest Y marginal TC_ID: ", closest_y_marginal_point$TC_ID),
color = "seagreen", hjust = 1, size = 4, fontface='bold') +
scale_color_viridis_c(option = "inferno", name = "Probability\nDensity") +
theme_minimal() +
ggtitle(paste("Basin:", basin, "| Return Period:", target_rp))
break
output_filepath <- file.path(outputdir, paste(basin, target_rp, xvar, yvar, ".png", sep='_'))
ggsave(output_filepath, width = 6,height = 5, dpi = 300, bg='white')
}
}
}
# Compute RP contour and PDF
rp_contour <- joint_return_period_contour(result, target_rp = target_rp, lambda = 3.38)
rp_contour$pdf <- (rp_contour$pdf - min(rp_contour$pdf)) / (max(rp_contour$pdf) - min(rp_contour$pdf))
# Find the most likely point along the isoline
max_pdf_index <- which.max(rp_contour$pdf)
most_likely_point <- rp_contour[max_pdf_index, c("x", "y")]
# Closest raw data point to most likely point
distances <- rdist(as.matrix(df[, c(xvar, yvar)]), as.matrix(most_likely_point))
closest_most_likely_index <- which.min(distances)
closest_most_likely_point <- df[closest_most_likely_index, c(xvar, yvar)]
closest_most_likely_point$TC_ID <- closest_most_likely_index
# --- Compute marginal quantiles directly from the fitted distributions ---
p_selected <- 1 - 1/target_rp
x_params <- result$marginals$x$fit$estimate
y_params <- result$marginals$y$fit$estimate
# Compute marginal 100-yr quantiles
x_marginal_sel <- do.call(result$marginals$x$quantile, c(list(p = p_selected), as.list(x_params)))
y_marginal_sel <- do.call(result$marginals$y$quantile, c(list(p = p_selected), as.list(y_params)))
tolerance <- 1 # adjust based on data scale
dist_to_isoline <- rdist(as.matrix(df[, c(xvar, yvar)]), as.matrix(rp_contour[, c("x", "y")]))
min_dist_to_isoline <- apply(dist_to_isoline, 1, min)
df_on_isoline <- df[min_dist_to_isoline < tolerance, , drop = FALSE]
# Save original row indices as TC_ID
df_on_isoline$TC_ID <- as.integer(rownames(df_on_isoline))
# Closest points to marginals on isoline
closest_x_marginal_index <- which.min(abs(df_on_isoline[[xvar]] - x_marginal_sel))
closest_y_marginal_index <- which.min(abs(df_on_isoline[[yvar]] - y_marginal_sel))
closest_x_marginal_point <- df_on_isoline[closest_x_marginal_index, c(xvar, yvar, "TC_ID")]
closest_y_marginal_point <- df_on_isoline[closest_y_marginal_index, c(xvar, yvar, "TC_ID")]
# Append to results table
selected_points <- rbind(selected_points,
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_most_likely_point$TC_ID,
point_type = "Most likely joint"),
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_x_marginal_point$TC_ID,
point_type = "Closest X marginal"),
data.frame(basin = basin,
return_period = target_rp,
TC_ID = closest_y_marginal_point$TC_ID,
point_type = "Closest Y marginal"))
# Save original row indices as TC_ID
df_on_isoline$TC_ID <- as.integer(rownames(df_on_isoline))
df_on_isoline
dist_to_isoline <- rdist(as.matrix(df[, c(xvar, yvar)]), as.matrix(rp_contour[, c("x", "y")]))
dist_to_isoline
min_dist_to_isoline <- apply(dist_to_isoline, 1, min)
min_dist_to_isoline
rp_contour$pdf <- (rp_contour$pdf - min(rp_contour$pdf)) / (max(rp_contour$pdf) - min(rp_contour$pdf))
max_pdf_index <- which.max(rp_contour$pdf)
most_likely_point <- rp_contour[max_pdf_index, c("x", "y")]
most_likely_point
max_pdf_index
rp_contour <- joint_return_period_contour(result, target_rp = target_rp, lambda = 3.38)
result
target_rp
# Global settings
setwd('C:\\Users\\lelise\\Documents\\GitHub\\flood_model_carolinas\\syntheticTCs_cmpdfld\\analysis\\05_copula')
source("fit_marginals_and_copula.R")
source("joint_return_period_contour.R")
library(ggplot2)
library(fields) # rdist for pairwise Euclidean distances
library(akima)
library(patchwork)
datadir = 'Z:\\Data-Expansion\\users\\lelise\\projects\\Carolinas_SFINCS\\Chapter3_SyntheticTCs\\05_ANALYSIS\\01_return_period_tables'
outputdir = 'Z:\\Data-Expansion\\users\\lelise\\projects\\Carolinas_SFINCS\\Chapter3_SyntheticTCs\\05_ANALYSIS\\06_copula\\design_events'
# Define variable pairs
variable_pairs <- list(
list(xvar = 'stormtide', yvar = 'AvgmaxRR', zvar = 'Total_Area_sqkm_RP', climate='ncep'),
list(xvar = 'meanMaxWS', yvar = 'MeanTotPrecipMM', zvar = 'Total_Area_sqkm_RP', climate='ncep')
)
basins <- c('Neuse') #, 'Pamlico')#, c('OnslowBay','Pamlico') #c('LowerPeeDee','CapeFear')
rps <- c(100)
# Initialize an empty data frame to store all selected points
selected_points <- data.frame(
basin = character(),
return_period = numeric(),
TC_ID = integer(),
point_type = character(),
stringsAsFactors = FALSE
)
for (basin in basins) {
for (pair in variable_pairs) {
xvar <- pair$xvar
yvar <- pair$yvar
zvar <- pair$zvar
climate <- pair$climate
# Load and clean data
filepath <- file.path(datadir, paste0(basin, "_data_rp_", climate, ".csv"))
if (!file.exists(filepath)) next
df <- read.csv(filepath)[, c(xvar, yvar, zvar,
'Runoff_Area_sqkm_RP',
'Coastal_Area_sqkm_RP',
'Compound_Area_sqkm_RP')]
df <- na.omit(df)
# Fit marginals and copula
x <- df[[xvar]]
y <- df[[yvar]]
result <- fit_marginals_and_copula(x, y)
for (target_rp in rps){
# Compute RP contour and PDF
rp_contour <- joint_return_period_contour(result, target_rp = target_rp, lambda = 3.38)
rp_contour$pdf <- (rp_contour$pdf - min(rp_contour$pdf)) / (max(rp_contour$pdf) - min(rp_contour$pdf))
break
#   # Find the most likely point along the isoline
#   max_pdf_index <- which.max(rp_contour$pdf)
#   most_likely_point <- rp_contour[max_pdf_index, c("x", "y")]
#
#   # Closest raw data point to most likely point
#   distances <- rdist(as.matrix(df[, c(xvar, yvar)]), as.matrix(most_likely_point))
#   closest_most_likely_index <- which.min(distances)
#   closest_most_likely_point <- df[closest_most_likely_index, c(xvar, yvar)]
#   closest_most_likely_point$TC_ID <- closest_most_likely_index
#
#   # --- Compute marginal quantiles directly from the fitted distributions ---
#   p_selected <- 1 - 1/target_rp
#   x_params <- result$marginals$x$fit$estimate
#   y_params <- result$marginals$y$fit$estimate
#
#   # Compute marginal 100-yr quantiles
#   x_marginal_sel <- do.call(result$marginals$x$quantile, c(list(p = p_selected), as.list(x_params)))
#   y_marginal_sel <- do.call(result$marginals$y$quantile, c(list(p = p_selected), as.list(y_params)))
#
#   # -------------------------------
#   # Select the events **near isoline** first
#   # -------------------------------
#   tolerance <- 1 # adjust based on data scale
#   dist_to_isoline <- rdist(as.matrix(df[, c(xvar, yvar)]), as.matrix(rp_contour[, c("x", "y")]))
#   min_dist_to_isoline <- apply(dist_to_isoline, 1, min)
#   df_on_isoline <- df[min_dist_to_isoline < tolerance, , drop = FALSE]
#
#   # Save original row indices as TC_ID
#   df_on_isoline$TC_ID <- as.integer(rownames(df_on_isoline))
#
#   # Closest points to marginals on isoline
#   closest_x_marginal_index <- which.min(abs(df_on_isoline[[xvar]] - x_marginal_sel))
#   closest_y_marginal_index <- which.min(abs(df_on_isoline[[yvar]] - y_marginal_sel))
#
#   closest_x_marginal_point <- df_on_isoline[closest_x_marginal_index, c(xvar, yvar, "TC_ID")]
#   closest_y_marginal_point <- df_on_isoline[closest_y_marginal_index, c(xvar, yvar, "TC_ID")]
#
#   # Append to results table
#   selected_points <- rbind(selected_points,
#                            data.frame(basin = basin,
#                                       return_period = target_rp,
#                                       TC_ID = closest_most_likely_point$TC_ID,
#                                       point_type = "Most likely joint"),
#                            data.frame(basin = basin,
#                                       return_period = target_rp,
#                                       TC_ID = closest_x_marginal_point$TC_ID,
#                                       point_type = "Closest X marginal"),
#                            data.frame(basin = basin,
#                                       return_period = target_rp,
#                                       TC_ID = closest_y_marginal_point$TC_ID,
#                                       point_type = "Closest Y marginal"))
#
#   # Plot
#   ggplot() +
#     geom_point(data = df, aes_string(x = xvar, y = yvar), alpha = 0.5) +
#     geom_path(data = rp_contour, aes(x = x, y = y, color = pdf), size = 1.5) +
#
#     # Points
#     geom_point(aes(x = closest_most_likely_point[[xvar]], y = closest_most_likely_point[[yvar]]),
#                color='black', fill = "firebrick1", size = 4, shape = 21, stroke=1) +   # Closest raw point
#     geom_point(aes(x = closest_x_marginal_point[[xvar]], y = closest_x_marginal_point[[yvar]]),
#                 color='black', fill = "steelblue2", size = 4, shape = 22, stroke=1) + # Closest x marginal
#     geom_point(aes(x = closest_y_marginal_point[[xvar]], y = closest_y_marginal_point[[yvar]]),
#                 color='black', fill = "seagreen", size = 4, shape = 22, stroke=1) +# Closest y marginal
#
#     annotate("text", x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.95,
#              label = paste0("Most likely Joint TC_ID: ", closest_most_likely_point$TC_ID),
#              color = "firebrick1", hjust = 1, size = 4,fontface='bold') +
#     annotate("text", x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.90,
#              label = paste0("Closest X marginal TC_ID: ", closest_x_marginal_point$TC_ID),
#              color = "steelblue2", hjust = 1, size = 4,fontface='bold') +
#     annotate("text",
#              x = max(df[[xvar]])*0.95, y = max(df[[yvar]])*0.85,
#              label = paste0("Closest Y marginal TC_ID: ", closest_y_marginal_point$TC_ID),
#              color = "seagreen", hjust = 1, size = 4, fontface='bold') +
#
#     scale_color_viridis_c(option = "inferno", name = "Probability\nDensity") +
#     theme_minimal() +
#     ggtitle(paste("Basin:", basin, "| Return Period:", target_rp))
#
# output_filepath <- file.path(outputdir, paste(basin, target_rp, xvar, yvar, ".png", sep='_'))
# ggsave(output_filepath, width = 6,height = 5, dpi = 300, bg='white')
}
}
}
